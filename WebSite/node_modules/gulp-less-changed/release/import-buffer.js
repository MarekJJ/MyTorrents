'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var fs = require('fs');
var Promise = require('bluebird');
var path = require('path');
var os = require('os');
var crypto = require('crypto');
var mkdirp = require('mkdirp');
var fsAsync = Promise.promisifyAll(fs);
var mkdirpAsync = Promise.promisify(mkdirp);
var listImports;
(function (listImports) {
    var ExpectedError = (function (_super) {
        __extends(ExpectedError, _super);
        function ExpectedError() {
            _super.apply(this, arguments);
        }
        return ExpectedError;
    }(Error));
    var perBufferImportCache = {};
    var ImportBuffer = (function () {
        function ImportBuffer(importLister, bufferKey) {
            this.bufferKey = bufferKey;
            if (!importLister || !(importLister instanceof Function)) {
                throw new Error('Invalid importer.');
            }
            if (!bufferKey) {
                throw new Error('A buffer key is required.');
            }
            this.importLister = importLister;
            this.importCache = perBufferImportCache[bufferKey];
            if (!this.importCache) {
                this.importCache = perBufferImportCache[bufferKey] = {};
            }
        }
        ImportBuffer.prototype.modifiedTimeIsTheSame = function (info) {
            return fsAsync.statAsync(info.path)
                .then(function (stat) {
                var same = stat.mtime.getTime() === info.time;
                if (!same) {
                    return Promise.reject(new ExpectedError('changed'));
                }
                return Promise.resolve(same);
            })
                .catch(function () {
                return Promise.reject(new ExpectedError('changed'));
            });
        };
        ImportBuffer.prototype.getCacheFile = function (filePath) {
            var filePathKey = crypto.createHash('md5').update(filePath).digest('hex') + "_" + path.basename(filePath);
            var outputPath = path.join(os.tmpdir(), this.bufferKey);
            return path.join(outputPath, filePathKey);
        };
        ImportBuffer.prototype.loadPreviousResults = function (filePath) {
            var existingImports = this.importCache[filePath];
            if (existingImports) {
                return Promise.resolve(existingImports);
            }
            var cacheFile = this.getCacheFile(filePath);
            return fsAsync.readFileAsync(cacheFile)
                .then(function (data) {
                return JSON.parse(data);
            })
                .catch(Error, function (error) {
                if (error.code !== 'ENOENT') {
                    console.error("Failed to load cached results from '" + cacheFile + "'. " + error);
                }
                return null;
            });
        };
        ImportBuffer.prototype.cacheResults = function (filePath, imports) {
            this.importCache[filePath] = imports;
            var cacheFile = this.getCacheFile(filePath);
            var outputPath = path.dirname(cacheFile);
            return mkdirpAsync(outputPath)
                .then(function () { return fsAsync.writeFileAsync(cacheFile, JSON.stringify(imports)); })
                .catch(function (error) {
                console.error("Failed to cache results to '" + cacheFile + "'. " + error);
                return imports;
            })
                .then(function () { return imports; });
        };
        ImportBuffer.prototype.listImports = function (file) {
            var _this = this;
            var useImportLister = function () {
                return _this.importLister(file)
                    .then(function (results) { return _this.cacheResults(file.path, results); })
                    .catch(function (error) {
                    console.error("An unknown error occurred: " + error);
                    return [];
                });
            };
            return this.loadPreviousResults(file.path)
                .then(function (existingImports) {
                if (existingImports) {
                    return Promise.all(existingImports.map(_this.modifiedTimeIsTheSame))
                        .then(function (results) {
                        return Promise.resolve(existingImports);
                    })
                        .catch(ExpectedError, function () {
                        return useImportLister();
                    });
                }
                return useImportLister();
            });
        };
        return ImportBuffer;
    }());
    listImports.ImportBuffer = ImportBuffer;
})(listImports || (listImports = {}));
module.exports = listImports;

//# sourceMappingURL=import-buffer.js.map
