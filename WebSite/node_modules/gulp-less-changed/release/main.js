'use strict';
var Promise = require('bluebird');
var through = require('through2');
var fs = require('fs');
var gutil = require('gulp-util');
var import_lister_1 = require('./import-lister');
var import_buffer_1 = require('./import-buffer');
var crypto = require('crypto');
var fsAsync = Promise.promisifyAll(fs);
var MODULE_NAME = 'gulp-less-changed';
var gulpLessChanged;
(function (gulpLessChanged) {
    function checkImportsHaveChanged(file, mainFileDate, importBuffer) {
        function importHasChanged(importFile) {
            return importFile.time > mainFileDate.getTime();
        }
        return importBuffer.listImports(file)
            .then(function (imports) {
            return imports.some(importHasChanged);
        });
    }
    function run(options) {
        options = options || {};
        var getOutputFileName = options.getOutputFileName || (function (input) { return gutil.replaceExtension(input, '.css'); });
        var importLister = new import_lister_1.ImportLister(options);
        var instanceKey = crypto.createHash('md5').update(__dirname + JSON.stringify(options)).digest('hex');
        var bufferKey = MODULE_NAME + "-" + instanceKey;
        var importBuffer = new import_buffer_1.ImportBuffer(importLister.listImports.bind(importLister), bufferKey);
        function transform(file, enc, callback) {
            var _this = this;
            if (file.isNull()) {
                return callback(null, null);
            }
            var outputFile = getOutputFileName(file.path);
            fsAsync.statAsync(outputFile)
                .then(function (stats) {
                if (stats.mtime < file.stat.mtime) {
                    _this.push(file);
                    return { outputAge: stats.mtime, changed: true };
                }
                return { outputAge: stats.mtime, changed: false };
            }, function (error) {
                if (error.code === 'ENOENT') {
                    _this.push(file);
                    return { outputAge: null, changed: true };
                }
                throw error;
            })
                .then(function (intermediateResult) {
                if (intermediateResult.changed) {
                    return Promise.resolve(false);
                }
                return checkImportsHaveChanged(file, intermediateResult.outputAge, importBuffer)
                    .catch(function (error) {
                    console.error(error);
                    return true;
                });
            })
                .then(function (importsHaveChanged) {
                if (importsHaveChanged) {
                    _this.push(file);
                }
            })
                .then(function () { return callback(null, null); })
                .catch(function (error) {
                _this.emit('error', new gutil.PluginError(MODULE_NAME, "Error processing '" + file.path + "': " + error));
                callback(null, null);
            });
        }
        return through.obj(transform);
    }
    gulpLessChanged.run = run;
})(gulpLessChanged || (gulpLessChanged = {}));
module.exports = gulpLessChanged.run;

//# sourceMappingURL=main.js.map
